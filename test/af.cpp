/*
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * Copyright (C) 2012-2024  Matwey V. Kornilov <matwey.kornilov@gmail.com>
 */

#include <limits>

#include <cppunit/TestAssert.h>
#include <cppunit/TestCase.h>
#include <cppunit/Portability.h>
#include <cppunit/extensions/HelperMacros.h>
#include <cppunit/extensions/TestFactoryRegistry.h>
#include <cppunit/ui/text/TestRunner.h>

#include <xtensor/io/xio.hpp>
#include <xtensor/containers/xarray.hpp> // IWYU pragma: keep
#include <xtensor/containers/xtensor.hpp>

#include <weif/af/circular.h>
#include <weif/af/point.h>
#include <weif/af/square.h>
#include <weif/af/gauss.h>

#include "xexpression.h"


class test_af_suite: public CppUnit::TestCase {
CPPUNIT_TEST_SUITE(test_af_suite);
CPPUNIT_TEST(test_circular1);
CPPUNIT_TEST(test_circular_vec1);
CPPUNIT_TEST(test_annular1);
CPPUNIT_TEST(test_annular_vec1);
CPPUNIT_TEST(test_cross_annular1);
CPPUNIT_TEST(test_cross_annular2);
CPPUNIT_TEST(test_cross_annular_vec1);
CPPUNIT_TEST(test_cross_annular_vec2);
CPPUNIT_TEST(test_point1);
CPPUNIT_TEST(test_point_vec1);
CPPUNIT_TEST(test_point_vec2);
CPPUNIT_TEST(test_square1);
CPPUNIT_TEST(test_square2);
CPPUNIT_TEST(test_square_vec1);
CPPUNIT_TEST(test_gauss1);
CPPUNIT_TEST(test_gauss_vec1);
CPPUNIT_TEST_SUITE_END();

void test_circular1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const circular<double> af{};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.97557820345282925544738037599840241249, af(0.1), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.90527056926709826543687436589706043937, af(0.2), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.79745112049841285396087207337350145069, af(0.3), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.66451326578645121632531346910734726067, af(0.4), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.52085499634171633388451850905545890177, af(0.5), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.38064186165252341564739554410558523018, af(0.6), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.25577177637369743025174833977161815215, af(0.7), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.15440278390591541872848388641857869804, af(0.8), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.080268510286597479867705768154527185659, af(0.9), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.032830452075419517493214219116742182043, af(1.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0045702276655243839509360474652512460908, af(2.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00060488171548396292171591681162427788157, af(4.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00018274993357362021237148215658828211404, af(6.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000077857738116575996557193284367527741371, af(8.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000040099342229572102544189269460965266392, af(10.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000023297399065979598913157367604140222006, af(12.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000014712721201644252120925506551088489092, af(14.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000098772835964288263669519569071382502047, af(16.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000006948584101381736894948005247208674993, af(18.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000050722104418580991006410526916452587537, af(20.0), delta);
}

void test_circular_vec1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		1.0,
		0.97557820345282925544738037599840241249,
		0.032830452075419517493214219116742182043,
		0.000040099342229572102544189269460965266392
	};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const circular<double> af{};
	xt::xarray<double> actual = af(args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_annular1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const annular<double> af{0.5};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.96952615608590915008004059224757042018, af(0.1), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.8824189299695181676075124239585852998, af(0.2), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.75082649938146086251078797295979808527, af(0.3), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.59251518926478159272239156996326435115, af(0.4), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.42769905882685446251072719960161505663, af(0.5), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.27557110594165059403783771466779742653, af(0.6), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.15123266413662958754204384737416166606, af(0.7), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.063602814850634058728204204909611281509, af(0.8), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.014651742552721604892125465725656310428, af(0.9), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000010432409682104119040509197686587990612, af(1.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.022660845524945452862890672495686973148, af(2.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00010522597358420914506433525812504207407, af(4.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00093180137852842045277002391525895758424, af(6.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000012722227810271925254357005450935199733, af(8.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00020573925983508204488321432110992697012, af(10.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000003722903812475180164900865372250601061, af(12.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000075694027571430171647440867164709004679, af(14.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000015604633257339527793568913708146413216, af(16.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000035803988981825795149495789673411768507, af(18.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00000079579675050707413378637344336522559154, af(20.0), delta);
}

void test_annular_vec1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		1.0,
		0.96952615608590915008004059224757042018,
		0.0000010432409682104119040509197686587990612,
		0.00020573925983508204488321432110992697012
	};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const annular<double> af{0.5};
	xt::xarray<double> actual = af(args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_cross_annular1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const cross_annular<double> af{2.0, 0.5, 0.25};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.93386338494461007056370109893540622419, af(0.1), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.75494885525314392828971517407641258886, af(0.2), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.5140607475465017150086093935513802287, af(0.3), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.27380534202954486552955441451726871086, af(0.4), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.086074193310102046295949705060340013674, af(0.5), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(-0.02380277255526337168265921011205010201, af(0.6), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(-0.060350069605476383390762796114815502145, af(0.7), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(-0.049073921634571131591756366323461733623, af(0.8), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(-0.021243750760324403957345342038933046622, af(0.9), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(-0.00012279567023698388639258514589261872756, af(1.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0057675176796296260742531357612607858639, af(2.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000050315890588266159049923898673526330443, af(4.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00023347889642976274424943007587357899534, af(6.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000061089433876280834114655085753314730986, af(8.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000051384308679875252787619942323952809653, af(10.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000017906954018994384872112353240899039146, af(12.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000018878453273193474850708380918771778653, af(14.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00000075125306385007565082814600131253535235, af(16.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000089227201326543507767780302952019977783, af(18.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00000038333475874090278379072664144132273568, af(20.0), delta);
}

void test_cross_annular2() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const cross_annular<double> af{1.0, 0.0, 0.0};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.97557820345282925544738037599840241249, af(0.1), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.90527056926709826543687436589706043937, af(0.2), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.79745112049841285396087207337350145069, af(0.3), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.66451326578645121632531346910734726067, af(0.4), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.52085499634171633388451850905545890177, af(0.5), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.38064186165252341564739554410558523018, af(0.6), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.25577177637369743025174833977161815215, af(0.7), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.15440278390591541872848388641857869804, af(0.8), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.080268510286597479867705768154527185659, af(0.9), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.032830452075419517493214219116742182043, af(1.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0045702276655243839509360474652512460908, af(2.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00060488171548396292171591681162427788157, af(4.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00018274993357362021237148215658828211404, af(6.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000077857738116575996557193284367527741371, af(8.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000040099342229572102544189269460965266392, af(10.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000023297399065979598913157367604140222006, af(12.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000014712721201644252120925506551088489092, af(14.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000098772835964288263669519569071382502047, af(16.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.000006948584101381736894948005247208674993, af(18.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.0000050722104418580991006410526916452587537, af(20.0), delta);
}

void test_cross_annular_vec1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		1.0,
		0.93386338494461007056370109893540622419,
		-0.00012279567023698388639258514589261872756,
		0.000051384308679875252787619942323952809653
	};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const cross_annular<double> af{2.0, 0.5, 0.25};
	xt::xarray<double> actual = af(args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_cross_annular_vec2() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		1.0,
		0.97557820345282925544738037599840241249,
		0.032830452075419517493214219116742182043,
		0.000040099342229572102544189269460965266392
	};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const cross_annular<double> af{1.0, 0.0, 0.0};
	xt::xarray<double> actual = af(args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_point1() {
	using namespace weif::af;

	const point<double> af{};

	CPPUNIT_ASSERT_EQUAL(1.0, af(0.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.1));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.2));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.3));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.4));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.5));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.6));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.7));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.8));
	CPPUNIT_ASSERT_EQUAL(1.0, af(0.9));
	CPPUNIT_ASSERT_EQUAL(1.0, af(1.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(2.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(4.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(6.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(8.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(10.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(12.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(14.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(16.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(18.0));
	CPPUNIT_ASSERT_EQUAL(1.0, af(20.0));
}

void test_point_vec1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {1.0, 1.0, 1.0, 1.0};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const point<double> af{};
	xt::xarray<double> actual = af(args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_point_vec2() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		{1.0, 1.0, 1.0, 1.0},
		{1.0, 1.0, 1.0, 1.0},
		{1.0, 1.0, 1.0, 1.0},
		{1.0, 1.0, 1.0, 1.0}};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const point<double> af{};
	xt::xarray<double> actual = af(args, args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_square1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const square<double> af{};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.96753120927507897864278592400778224587, af(0.1, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.87514020008338080393885119986768004915, af(0.2, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.73683972932225036190552245005778262937, af(0.3, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.57278669718491859750968261581970923414, af(0.4, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.40528473456935108577551785283891055562, af(0.5, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.25457186541551927186561553089194342633, af(0.6, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.13533790946735205300724675797617704617, af(0.7, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.05469626250521127398847633159820942949, af(0.8, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.011944829744136771839732436791876860686, af(0.9, 0.0), delta);
}

void test_square2() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const square<double> af{};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0, 0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.96753120927507897864278592400778224587, af(0.0, 0.1), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.87514020008338080393885119986768004915, af(0.0, 0.2), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.73683972932225036190552245005778262937, af(0.0, 0.3), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.57278669718491859750968261581970923414, af(0.0, 0.4), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.40528473456935108577551785283891055562, af(0.0, 0.5), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.25457186541551927186561553089194342633, af(0.0, 0.6), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.13533790946735205300724675797617704617, af(0.0, 0.7), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.05469626250521127398847633159820942949, af(0.0, 0.8), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.011944829744136771839732436791876860686, af(0.0, 0.9), delta);
}

void test_square_vec1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		{1.0, 0.96753120927507897864278592400778224587},
		{0.96753120927507897864278592400778224587, 0.93611664092129667462914813285802163803}
	};
	const xt::xarray<double> args = {0.0, 0.1};
	const square<double> af{};
	xt::xarray<double> actual = af(args, args);

	XT_ASSERT_XEXPRESSION_CLOSE(expected, actual, delta);
}

void test_gauss1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const gauss<double> af{};

	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, af(0.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.99004983374916805165034776550942575968, af(0.1), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.96078943915232320197237679117804541059, af(0.2), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.91393118527122816442466976065582081843, af(0.3), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.85214378896621131196639664702353209789, af(0.4), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.7788007830714048682451702669783206473, af(0.5), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.69767632607103098904641302112282260219, af(0.6), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.61262639418441600641460256288947477873, af(0.7), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.52729242404304849167752934166987246197, af(0.8), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.44485806622294111077464538418106828997, af(0.9), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.36787944117144232159552377016146086745, af(1.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.018315638888734180293718021273241242212, af(2.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(0.00000011253517471925911451377517906012719164, af(4.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(2.3195228302435693883122636097380800411e-16, af(6.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.603810890548637852976087034142335381e-28, af(8.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(3.7200759760208359629596958038631183374e-44, af(10.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(2.8946403116483002802938374650110306514e-63, af(12.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(7.5558190197119603550515145467590847601e-86, af(14.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(6.6162610567094852610295308073620645218e-112, af(16.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.9435148500492927332935100661481034392e-141, af(18.0), delta);
	CPPUNIT_ASSERT_DOUBLES_EQUAL(1.9151695967140056950198397786542643507e-174, af(20.0), delta);
}

void test_gauss_vec1() {
	using namespace weif::af;

	constexpr auto delta = std::numeric_limits<double>::epsilon();
	const xt::xarray<double> expected = {
		1.0,
		0.99004983374916805165034776550942575968,
		0.36787944117144232159552377016146086745,
		3.7200759760208359629596958038631183374e-44
	};
	const xt::xarray<double> args = {0.0, 0.1, 1.0, 10.0};
	const gauss<double> af{};
	xt::xarray<double> actual = af(args);

	CPPUNIT_ASSERT(xt::allclose(expected, actual, delta));
}

};
CPPUNIT_TEST_SUITE_REGISTRATION(test_af_suite);

int main(int argc, char **argv) {
	CppUnit::TextUi::TestRunner runner;
	CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
	runner.addTest(registry.makeTest());
	return !runner.run("", false);
}

